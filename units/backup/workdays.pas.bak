// CoYOT(e) - Control Your Overtimes (easily)
unit workdays;

interface

uses Classes, SysUtils, DateUtils, fgl, Grids,
      funcs;

type

//############################################ DAY ###########################################################
  TWorkDay = class

  private
    FStartHour: integer;      // The hour work starts that day
    FStartMinute: integer;    // The minute work starts that day
    FEndHour: integer;        // The hour work ends that day
    FEndMinute: integer;      // The minute work ends that day

    FWeekDay: integer;         // Weekday 1 - 7
    FDate: TDate;              // Date of the specific Day
    FAdditionalTime: double;   // Time to add or substract additional time e.g. if you took 1 hour off

    function calcDifference: double;    // The function that will actually calculate work time of one day

  public
    procedure Clear;
    procedure setTime(hour, min: integer; mode: boolean);
    function WeekDayToText: String;
    function getAmountOfTime: Double;

    property StartHour: Integer read FStartHour write FStartHour;
    property StartMinute: Integer read FStartMinute write FStartMinute;
    property EndHour: Integer read FEndHour write FEndHour;
    property EndMinute: Integer read FEndMinute write FEndMinute;
    property Date: TDate read FDate write FDate;
    property Weekday: integer read FWeekday write FWeekday;
    property AdditionalTime: double read FAdditionaltime write FAdditionaltime;
    property TimeWorked: double read calcDifference;

  end;

  TWorkDays = specialize TFPGObjectList<TWorkDay>;

//############################################ Period ###########################################################
  TWorkWeek = class
  private
    FWeekLabel: String;                 // A Description Text shown in the list
    FDays: TWorkDays;                   // The Days related to this period
    FFromDate: TDate;
    FToDate: TDate;
    FWeekLength: integer;               // Workdays in that particular week
    FIntendedTimePerDay: double;        // The time you intend to work per day
    FPausePerDay: Double;               // Obligatory Pause Time
    //FAverageTime: Double;             // Durchschnittsarbeitszeit pro Tag (Zur Kontrolle)

    function calcAverageTime: double;

  public
    constructor Create;
    constructor Create(AFromDate, AToDate: TDate); overload;
    destructor Destroy;
    procedure Clear;
    procedure assign(AWeek: TWorkWeek);
    function getSum: Double;

    property WeekLength: Integer read FWeekLength write FWeekLength;
    property IntendedTimePerDay: Double read FIntendedTimePerDay write FIntendedTimePerDay;
    property AverageTimePerDay: Double read calcAverageTime;
    property FromDate: TDate read FFromDate write FFromDate;
    property ToDate: TDate read FToDate write FToDate;
    property Days: TWorkDays read FDays write FDays;
    property WeekLabel: String read FWeekLabel write FWeekLabel;

  end;

TWeekList = specialize TFPGObjectList<TWorkWeek>;

// ############################################### additional Functions ################################################

procedure ClearStringGrid(AGrid: TStringGrid);
procedure WeeksToStringGrid(AGrid: TStringGrid; AWeeklist: TWeekList);
function TimeToText(hour,min: Integer):String;
procedure WeekDaysToStringGrid(AGrid: TStringGrid; AWeek: TWorkWeek);


const
  txtWeekDays: array[1..7] of string = ('Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun');

implementation


//############################################ DAY ###########################################################

procedure TWorkDay.Clear;
begin
  FStartHour := 0;
  FStartMinute := 0;
  FEndHour := 0;
  FEndMinute := 0;

  FDate := 0;
  FAdditionalTime := 0;
end;

procedure TWorkDay.setTime(hour, min: integer; mode: boolean);
begin
  if (hour > 23) then
    hour := 23;
  if (min > 59) then
    min := 59;
  if (hour < 0) then
    hour := 0;
  if (min < 0) then
    min := 0;

  if not mode then
  begin
    FStartHour := hour;
    FStartMinute := min;
  end
  else
  begin
    FEndHour := hour;
    FEndMinute := min;
  end;
end;

function TWorkDay.calcDifference: double;
begin
  Result := (FEndHour - FStartHour + ((FEndMinute - FStartMinute) / 60));
end;

function TWorkDay.WeekDayToText(): string;
begin
  if (FWeekday > 0) then
    Result := txtWeekdays[FWeekday] + DateToStr(FDate)
  else
    Result := DateToStr(FDate);
end;

function TWorkDay.getAmountOfTime: Double;
var
  StartTime: TDateTime;
  EndTime: TDateTime;
begin
  StartTime := self.FDate;
  EndTime := self.FDate;

  StartTime := StartTime + (60*60*FStartHour) + (60*FStartMinute);
  EndTime := EndTime + (60*60*FEndHour) + (60*FEndMinute);
  Result :=(EndTime - StartTime)/3600;
end;

//############################################ Week ###########################################################

constructor TWorkWeek.Create;
var
  I: Integer;
begin
  FDays := TWorkDays.Create(true);
  FWeekLabel := 'empty week';
  FWeekLength := 0;
  FIntendedTimePerDay := 8;
  FPausePerDay := 0.75;
end;

constructor TWorkWeek.Create(AFromDate, AToDate: TDate);
var
  I: Integer;
begin
  self.FromDate := AFromDate;
  self.ToDate := AToDate;
  self.WeekLength := DaysBetween(FToDate,FFromDate)+ 1;
  self.IntendedTimePerDay := 8;
  self.FPausePerDay := 0.75;
  self.FDays := TWorkDays.Create(true);
  self.FWeekLabel := DateToStr(FromDate) + '   to   ' + DateToStr(ToDate);
  for I := 0 to FWeekLength-1 do
  begin
    FDays.Add(TWorkDay.Create);
    FDays[I].Weekday := RealDayOfWeek(AFromDate + I);
    FDays[I].Date := AFromDate + I;
  end;
end;

destructor TWorkWeek.Destroy;
begin
  FDays.Free;
end;

procedure TWorkWeek.assign(AWeek: TWorkWeek);
var
  I: Integer;
begin
  self.FromDate := AWeek.FromDate;
  self.ToDate := AWeek.ToDate;
  self.WeekLength := AWeek.WeekLength;
  self.WeekLabel := AWeek.WeekLabel;
  self.IntendedTimePerDay := AWeek.IntendedTimePerDay;
  self.Days.Clear;
  for I := 0 to self.WeekLength -1 do
  begin
    self.Days.Add(TWorkDay.Create);
    self.Days[I].Date := AWeek.Days[I].Date;
    self.Days[I].Weekday := AWeek.Days[I].Weekday;
    //self.Days[I].
  end;
end;

function TWorkWeek.calcAverageTime: double;
var
  I: integer;
begin
  if (FDays.Count > 0) then
  begin
    for I := 0 to FDays.Count - 1 do
    begin
      Result := Result + FDays.Items[I].calcDifference;
    end;
    Result := Result / FDays.Count
  end
  else
  begin
    Result := 0;
  end;
end;

function TWorkWeek.getSum: Double;
var
  I: Integer;
begin
  Result := 0;
  for I := 0 to self.Days.Count-1 do
  begin
    Result := Result + self.Days[I].getAmountOfTime;
	end;
end;

procedure TWorkWeek.Clear;
begin
  FDays.Clear;
  FFromDate := 0;
  FToDate := 0;
  FWeekLength := 0;
  FIntendedTimePerDay := 8;
end;



// ############################################### additional Functions ################################################
function TimeToText(hour,min: Integer):String;
var
  txtHour, txtMin: String;
begin
  if (hour < 10) then
    txtHour := '0' + IntToStr(hour);
  if (min < 10) then
    txtMin := '0' + IntToStr(min)
  else
    txtMin := IntToStr(min);

  Result := txtHour + ':' + txtMin;
end;


procedure WeeksToStringGrid(AGrid: TStringGrid; AWeeklist: TWeekList);
var
  I: Integer;
begin
  clearStringGrid(AGrid);
  AGrid.RowCount := 1 + AWeekList.Count;
  for I := 0 to AWeekList.Count - 1 do
  begin
    AGrid.Cells[0,1+I] := IntToStr(I+1);
    AGrid.Cells[1,1+I] := AWeekList.Items[I].WeekLabel;
    AGrid.Cells[2,1+I] := IntToStr(AWeekList.Items[I].WeekLength);
  end;
end;

procedure ClearStringGrid(AGrid: TStringGrid);
begin
  while (AGrid.RowCount > 1) do
  begin
    AGrid.DeleteRow(AGrid.RowCount-1);
  end;
end;

procedure WeekDaysToStringGrid(AGrid: TStringGrid; AWeek: TWorkWeek);
var
  I: Integer;
begin
  clearStringGrid(AGrid);
  AGrid.RowCount := AWeek.WeekLength+1;

  // write contents to right grid
  for I := 1 to AWeek.WeekLength do
  begin

    AGrid.Cells[0,I] := IntToStr(I);
    AGrid.Cells[2,I] := DateToStr(AWeek.Days[I-1].Date);


    if (AWeek.Days[I-1].Weekday > 0) and (AWeek.Days[I-1].Weekday < 8) then
    begin
      AGrid.cells[1,I] := txtWeekdays[Aweek.Days[I-1].Weekday];
		end;

    if (AWeek.Days[I-1].StartMinute < 10) then
    begin
      AGrid.cells[3,I] := IntToStr(AWeek.Days[I-1].StartHour) + ':0' + IntToStr(AWeek.Days[I-1].StartMinute);
    end
    else
    begin
      AGrid.cells[3,I] := IntToStr(AWeek.Days[I-1].StartHour) + ':' + IntToStr(AWeek.Days[I-1].StartMinute);
    end;

    if (AWeek.Days[I-1].EndMinute < 10) then
    begin
      AGrid.cells[4,I] := IntToStr(AWeek.Days[I-1].EndHour) + ':0' + IntToStr(AWeek.Days[I-1].EndMinute);
    end
    else
    begin
      AGrid.cells[4,I] := IntToStr(AWeek.Days[I-1].EndHour) + ':' + IntToStr(AWeek.Days[I-1].EndMinute);
    end;
  end;

end;

end.
